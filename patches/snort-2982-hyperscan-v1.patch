 snort/configure.in                             |  28 ++
 snort/src/detection-plugins/sp_pattern_match.c | 119 ++++++++
 snort/src/detection-plugins/sp_pattern_match.h |   8 +
 snort/src/detection-plugins/sp_pcre.c          | 304 ++++++++++++++++++++-
 snort/src/detection-plugins/sp_pcre.h          |   9 +
 snort/src/fpcreate.c                           |  19 ++
 snort/src/sfutil/Makefile.am                   |   5 +
 snort/src/sfutil/hyperscan.c                   | 359 +++++++++++++++++++++++++
 snort/src/sfutil/hyperscan.h                   | 101 +++++++
 snort/src/sfutil/mpse.c                        |  54 ++++
 snort/src/sfutil/mpse_methods.h                |   4 +
 snort/src/snort.c                              |  12 +
 snort/src/snort.h                              |   8 +
 13 files changed, 1028 insertions(+), 2 deletions(-)

diff --git a/snort/configure.in b/snort/configure.in
index 804ce06..e72daf8 100644
--- a/snort/configure.in
+++ b/snort/configure.in
@@ -1244,6 +1244,34 @@ if test "x$enable_intel_soft_cpm" = "xyes"; then
     CPPFLAGS="${CPPFLAGS} -DINTEL_SOFT_CPM"
 fi
 
+AC_ARG_ENABLE(intel_hyperscan,
+[  --enable-intel-hyperscan  Enable Intel Hyperscan support],
+       enable_intel_hyperscan="$enableval", enable_intel_hyperscan="no")
+
+AC_ARG_WITH(intel_hyperscan_includes,
+	[  --with-intel-hyperscan-includes=DIR      Intel Hyperscan include directory],
+	[with_intel_hyperscan_includes="$withval"],[with_intel_hyperscan_includes="no"])
+
+AC_ARG_WITH(intel_hyperscan_libraries,
+	[  --with-intel-hyperscan-libraries=DIR     Intel Hyperscan library directory],
+	[with_intel_hyperscan_libraries="$withval"],[with_intel_hyperscan_libraries="no"])
+
+if test "x$with_intel_hyperscan_includes" != "xno"; then
+    enable_intel_hyperscan="yes"
+    CPPFLAGS="${CPPFLAGS} -I${with_intel_hyperscan_includes}"
+fi
+
+if test "x$with_intel_hyperscan_libraries" != "xno"; then
+    enable_intel_hyperscan="yes"
+    LDFLAGS="${LDFLAGS} -L${with_intel_hyperscan_libraries}"
+    LIBS="${LIBS} -lhs /usr/lib/gcc/aarch64-linux-gnu/7/libstdc++.a -lm"
+fi
+
+AM_CONDITIONAL(HAVE_INTEL_HYPERSCAN, test "x$enable_intel_hyperscan" = "xyes")
+if test "x$enable_intel_hyperscan" = "xyes"; then
+    CPPFLAGS="${CPPFLAGS} -DINTEL_HYPERSCAN"
+fi
+
 AC_ARG_ENABLE(shared_rep,
     [  --enable-shared-rep      Enable use of Shared Memory for Reputation (Linux only)],
        enable_shared_rep="$enableval", enable_shared_rep="no")
diff --git a/snort/src/detection-plugins/sp_pattern_match.c b/snort/src/detection-plugins/sp_pattern_match.c
index 447da7b..2dd5492 100644
--- a/snort/src/detection-plugins/sp_pattern_match.c
+++ b/snort/src/detection-plugins/sp_pattern_match.c
@@ -62,6 +62,10 @@
 #include "detection_util.h"
 #include "sf_sechash.h"
 
+#ifdef INTEL_HYPERSCAN
+#include <hs.h>
+#endif
+
 /********************************************************************
  * Macros
  ********************************************************************/
@@ -82,6 +86,10 @@ int lastType = PLUGIN_PATTERN_MATCH;
 int list_file_line;     /* current line being processed in the list file */
 #endif
 
+#ifdef INTEL_HYPERSCAN
+static hs_scratch_t *contentScratch = NULL;
+#endif
+
 /********************************************************************
  * Extern variables
  ********************************************************************/
@@ -145,6 +153,14 @@ static void PrintDupDOTPmds(PatternMatchData *pmd,
 /********************************************************************
  * Setup and parsing functions
  ********************************************************************/
+
+#ifdef INTEL_HYPERSCAN
+static void HyperscanCleanup(int unused, void *data) {
+    hs_free_scratch(contentScratch);
+    contentScratch = NULL;
+}
+#endif
+
 void SetupPatternMatch(void)
 {
     /* initial pmd setup options */
@@ -190,6 +206,12 @@ void SetupPatternMatch(void)
     RegisterPreprocessorProfile("content", &contentPerfStats, 3, &ruleOTNEvalPerfStats, NULL);
     RegisterPreprocessorProfile("uricontent", &uricontentPerfStats, 3, &ruleOTNEvalPerfStats, NULL);
 #endif
+
+#ifdef INTEL_HYPERSCAN
+    // Clean up Hyperscan resources at the end.
+    AddFuncToCleanExitList(HyperscanCleanup, NULL);
+#endif
+
     DEBUG_WRAP(DebugMessage(DEBUG_PATTERN_MATCH,
                 "Plugin: PatternMatch Initialized!\n"););
 }
@@ -932,6 +954,11 @@ void PatternMatchFree(void *d)
     if(pmd->shift_stride)
         free(pmd->shift_stride);
 
+#ifdef INTEL_HYPERSCAN
+    if (pmd->hs_db)
+        hs_free_database(pmd->hs_db);
+#endif
+
     free(pmd);
 }
 
@@ -1452,6 +1479,58 @@ void ValidateFastPattern(OptTreeNode *otn)
     }
 }
 
+#ifdef INTEL_HYPERSCAN
+
+static void make_hyperscan(PatternMatchData *idx) {
+    if (idx->hs_db) {
+        hs_free_database(idx->hs_db);
+        idx->hs_db = NULL;
+    }
+
+    unsigned flags = 0;
+    if (idx->nocase) {
+        flags |= HS_FLAG_CASELESS;
+    }
+
+    size_t hexlen = idx->pattern_size * 4;
+    char *hexbuf = SnortAlloc(hexlen + 1);
+    unsigned i;
+    char *buf;
+    for (i = 0, buf = hexbuf; i < idx->pattern_size; i++, buf += 4) {
+        snprintf(buf, 5, "\\x%02x", (unsigned char)idx->pattern_buf[i]);
+    }
+    hexbuf[hexlen] = '\0';
+
+    hs_compile_error_t *error = NULL;
+    hs_error_t rv = hs_compile(hexbuf, flags, HS_MODE_BLOCK, NULL, &idx->hs_db,
+                               &error);
+    free(hexbuf);
+
+    if (rv != HS_SUCCESS) {
+        if (error) {
+            FatalError("hs_compile() failed: %s\n", error->message);
+            hs_free_compile_error(error);
+            return;
+        } else {
+            FatalError("hs_compile() failed: returned error %d\n", rv);
+            return;
+        }
+    }
+
+    if (!idx->hs_db) {
+        FatalError("hs_compile() produced null database?\n");
+        return;
+    }
+
+    rv = hs_alloc_scratch(idx->hs_db, &contentScratch);
+    if (rv != HS_SUCCESS) {
+        FatalError("hs_alloc_scratch() failed: returned error %d\n", rv);
+        return;
+    }
+}
+
+#endif // INTEL_HYPERSCAN
+
 void make_precomp(PatternMatchData * idx)
 {
     if(idx->skip_stride)
@@ -1462,6 +1541,10 @@ void make_precomp(PatternMatchData * idx)
     idx->skip_stride = make_skip(idx->pattern_buf, idx->pattern_size);
 
     idx->shift_stride = make_shift(idx->pattern_buf, idx->pattern_size);
+
+#ifdef INTEL_HYPERSCAN
+    make_hyperscan(idx);
+#endif
 }
 
 static char *PayloadExtractParameter(char *data, int *result_len)
@@ -2213,6 +2296,35 @@ int uniSearchCI(const char *data, int dlen, PatternMatchData *pmd)
     return uniSearchReal(data, dlen, pmd, 1);
 }
 
+#ifdef INTEL_HYPERSCAN
+
+static int hyperscanCallback(unsigned int id, unsigned long long from,
+                             unsigned long long to, unsigned int flags,
+                             void *ctx) {
+    *(unsigned long long *)ctx = to;
+    return 1; // cease scanning
+}
+
+static int hyperscanSearch(const char *data, int dlen, const hs_database_t *db) {
+    unsigned long long match = 0;
+
+    hs_error_t err = hs_scan(db, data, dlen, 0, contentScratch,
+                             hyperscanCallback, &match);
+    if (err != HS_SUCCESS && err != HS_SCAN_TERMINATED) {
+        FatalError("hs_scan() failed: error %d\n", err);
+        return 1;
+    }
+
+    if (match == 0) { // No matches found.
+        return 0;
+    }
+
+    UpdateDoePtr((const uint8_t *)data + match, 0);
+    return 1;
+}
+
+#endif // INTEL_HYPERSCAN
+
 /*
  * single search function.
  *
@@ -2389,6 +2501,9 @@ static int uniSearchReal(const char *data, int dlen, PatternMatchData *pmd, int
     }
 #endif /* DEBUG_MSGS */
 
+#ifdef INTEL_HYPERSCAN
+    success = hyperscanSearch(base_ptr, depth, pmd->hs_db);
+#else
     if(nocase)
     {
         success = mSearchCI(base_ptr, depth,
@@ -2405,6 +2520,7 @@ static int uniSearchReal(const char *data, int dlen, PatternMatchData *pmd, int
                           pmd->skip_stride,
                           pmd->shift_stride);
     }
+#endif // INTEL_HYPERSCAN
 
 
 #ifdef DEBUG_MSGS
@@ -2761,6 +2877,9 @@ void PatternMatchDuplicatePmd(void *src, PatternMatchData *pmd_dup)
     pmd_dup->search = pmd_src->search;
     pmd_dup->skip_stride = pmd_src->skip_stride;
     pmd_dup->shift_stride = pmd_src->shift_stride;
+#ifdef INTEL_HYPERSCAN
+    pmd_dup->hs_db = pmd_src->hs_db;
+#endif
     pmd_dup->pattern_max_jump_size = pmd_src->pattern_max_jump_size;
     pmd_dup->fp = pmd_src->fp;
     pmd_dup->fp_only = pmd_src->fp_only;
diff --git a/snort/src/detection-plugins/sp_pattern_match.h b/snort/src/detection-plugins/sp_pattern_match.h
index 19e7db1..5d24dea 100644
--- a/snort/src/detection-plugins/sp_pattern_match.h
+++ b/snort/src/detection-plugins/sp_pattern_match.h
@@ -42,6 +42,11 @@
 /********************************************************************
  * Data structures
  ********************************************************************/
+
+#ifdef INTEL_HYPERSCAN
+struct hs_database;
+#endif
+
 typedef struct _PatternMatchData
 {
     int offset;             /* pattern search start offset */
@@ -71,6 +76,9 @@ typedef struct _PatternMatchData
     int (*search)(const char *, int, struct _PatternMatchData *);  /* search function */
     int *skip_stride; /* B-M skip array */
     int *shift_stride; /* B-M shift array */
+#ifdef INTEL_HYPERSCAN
+    struct hs_database *hs_db; /* Hyperscan database */
+#endif
     u_int pattern_max_jump_size; /* Maximum distance we can jump to search for
                                   * this pattern again. */
     OptFpList *fpl;         /* Pointer to the OTN FPList for this pattern */
diff --git a/snort/src/detection-plugins/sp_pcre.c b/snort/src/detection-plugins/sp_pcre.c
index 4dac2e5..8607a15 100644
--- a/snort/src/detection-plugins/sp_pcre.c
+++ b/snort/src/detection-plugins/sp_pcre.c
@@ -48,6 +48,10 @@
 
 #include <pcre.h>
 
+#ifdef INTEL_HYPERSCAN
+#include <hs.h>
+#endif
+
 #include "snort.h"
 #include "profiler.h"
 #ifdef PERF_PROFILING
@@ -67,6 +71,17 @@ extern PreprocStats ruleOTNEvalPerfStats;
  */
 static int s_pcre_init = 1;
 
+#ifdef INTEL_HYPERSCAN
+static hs_scratch_t *pcreScratch = NULL;
+static size_t total_pcre_count = 0;
+static size_t total_pcre_size = 0;
+static size_t total_hyperscan_size = 0;
+
+/* Switch on for correctness testing by always running pcre_exec. */
+#define INTEL_HYPERSCAN_CORRECTNESS_TEST 0
+
+#endif
+
 void SnortPcreInit(struct _SnortConfig *, char *, OptTreeNode *, int);
 void SnortPcreParse(struct _SnortConfig *, char *, PcreData *, OptTreeNode *);
 void SnortPcreDump(PcreData *);
@@ -76,12 +91,33 @@ void PcreFree(void *d)
 {
     PcreData *data = (PcreData *)d;
 
+#ifdef INTEL_HYPERSCAN
+    hs_free_database(data->hs_db);
+#endif
+
     free(data->expression);
     free(data->re);
     free(data->pe);
     free(data);
 }
 
+#ifdef INTEL_HYPERSCAN
+static void HyperscanCleanup(int unused, void *data) {
+    hs_free_scratch(pcreScratch);
+    pcreScratch = NULL;
+}
+
+static void HyperscanStats(struct _SnortConfig *sc, int unused, void *data)
+{
+    LogMessage("+--[HyperScan PCRE acceleration]------------------------------\n");
+    LogMessage("| Hyperscan version    : %s\n", hs_version());
+    LogMessage("| Number of PCREs      : %zu\n", total_pcre_count);
+    LogMessage("| Total PCRE size      : %zu bytes\n", total_pcre_size);
+    LogMessage("| Total Hyperscan size : %zu bytes\n", total_hyperscan_size);
+    LogMessage("+-------------------------------------------------------------\n");
+}
+#endif // INTEL_HYPERSCAN
+
 uint32_t PcreHash(void *d)
 {
     int i,j,k,l,expression_len;
@@ -163,6 +199,12 @@ void PcreDuplicatePcreData(void *src, PcreData *pcre_dup)
     pcre_dup->search_offset = 0;
     pcre_dup->pe = pcre_src->pe;
     pcre_dup->re = pcre_src->re;
+
+#ifdef INTEL_HYPERSCAN
+    pcre_dup->hs_db = pcre_src->hs_db;
+    pcre_dup->hs_flags = pcre_src->hs_flags;
+    pcre_dup->hs_noconfirm = pcre_src->hs_noconfirm;
+#endif
 }
 
 int PcreAdjustRelativeOffsets(PcreData *pcre, uint32_t search_offset)
@@ -189,6 +231,10 @@ void SetupPcre(void)
 #ifdef PERF_PROFILING
     RegisterPreprocessorProfile("pcre", &pcrePerfStats, 3, &ruleOTNEvalPerfStats, NULL);
 #endif
+#ifdef INTEL_HYPERSCAN
+    // Clean up Hyperscan resources at the end.
+    AddFuncToCleanExitList(HyperscanCleanup, NULL);
+#endif
 }
 
 static void Ovector_Init(struct _SnortConfig *sc, int unused, void *data)
@@ -234,11 +280,47 @@ void PcreCapture(struct _SnortConfig *sc, const void *code, const void *extra)
 #if SNORT_RELOAD
         AddFuncToReloadList(Ovector_Reload, NULL);
 #endif
+#ifdef INTEL_HYPERSCAN
+        AddFuncToPostConfigList(sc, HyperscanStats, NULL);
+#endif
         s_pcre_init = 0;
     }
 
 }
 
+#ifdef INTEL_HYPERSCAN
+static void CalcPcreSize(const PcreData *pcre_data) {
+    int rc;
+    hs_error_t err;
+
+    size_t pcre_size = 0, pcre_studysize = 0, hs_size = 0;
+    rc =
+        pcre_fullinfo(pcre_data->re, pcre_data->pe, PCRE_INFO_SIZE, &pcre_size);
+    if (rc) {
+        FatalError("pcre_fullinfo returned error %d\n", rc);
+        return;
+    }
+    rc = pcre_fullinfo(pcre_data->re, pcre_data->pe, PCRE_INFO_STUDYSIZE,
+                       &pcre_studysize);
+    if (rc) {
+        FatalError("pcre_fullinfo returned error %d\n", rc);
+        return;
+    }
+
+    if (pcre_data->hs_db != NULL) {
+        err = hs_database_size(pcre_data->hs_db, &hs_size);
+        if (err != HS_SUCCESS) {
+            FatalError("hs_database_size returned error %d\n", err);
+            return;
+        }
+    }
+
+    total_pcre_count++;
+    total_pcre_size += pcre_size + pcre_studysize;
+    total_hyperscan_size += hs_size;
+}
+#endif // INTEL_HYPERSCAN
+
 void SnortPcreInit(struct _SnortConfig *sc, char *data, OptTreeNode *otn, int protocol)
 {
     PcreData *pcre_data;
@@ -272,11 +354,19 @@ void SnortPcreInit(struct _SnortConfig *sc, char *data, OptTreeNode *otn, int pr
             free(pcre_data->pe);
         if (pcre_data->re)
             free(pcre_data->re);
+#ifdef INTEL_HYPERSCAN
+        if (pcre_data->hs_db)
+            hs_free_database(pcre_data->hs_db);
+#endif
 
         free(pcre_data);
         pcre_data = pcre_dup;
     }
 
+#ifdef INTEL_HYPERSCAN
+    CalcPcreSize(pcre_data);
+#endif
+
     /*
      * attach it to the context node so that we can call each instance
      * individually
@@ -303,6 +393,105 @@ static inline void ValidatePcreHttpContentModifiers(PcreData *pcre_data)
                 file_name, file_line);
 }
 
+#ifdef INTEL_HYPERSCAN
+
+static int hyperscan_fixed_width(const char *re, unsigned int hs_flags) {
+    hs_expr_info_t *info = NULL;
+    hs_compile_error_t *compile_error = NULL;
+
+    hs_error_t err = hs_expression_info(re, hs_flags, &info, &compile_error);
+    if (err != HS_SUCCESS) {
+        hs_free_compile_error(compile_error);
+        return 0;
+    }
+
+    if (!info) {
+        return 0;
+    }
+
+    int fixed_width = (info->min_width == info->max_width &&
+            info->max_width != 0xffffffff);
+    free(info);
+    return fixed_width;
+}
+
+static void HyperscanBuild(PcreData *pcre_data, const char *re,
+                           int pcre_compile_flags) {
+    if (pcre_data == NULL || pcre_data->re == NULL || pcre_data->pe == NULL ||
+        re == NULL) {
+        return;
+    }
+
+    /* Note that we also allow PCRE_UNGREEDY even though there is no Hyperscan
+     * flag for it. Greedy/ungreedy semantics make no difference for the
+     * prefilter use case, where the match offset reported by Hyperscan is not
+     * used. */
+
+    const int supported_pcre_flags =
+        PCRE_CASELESS | PCRE_DOTALL | PCRE_MULTILINE | PCRE_UNGREEDY;
+    if (pcre_compile_flags & ~supported_pcre_flags) {
+        DEBUG_WRAP(DebugMessage(DEBUG_PATTERN_MATCH,
+                                "fail, pcre '%s' unsupported flags=%d\n",
+                                pcre_data->expression,
+                                pcre_compile_flags & ~supported_pcre_flags));
+        return;
+    }
+
+    int hs_flags = HS_FLAG_ALLOWEMPTY;
+    if (pcre_compile_flags & PCRE_CASELESS)
+        hs_flags |= HS_FLAG_CASELESS;
+    if (pcre_compile_flags & PCRE_DOTALL)
+        hs_flags |= HS_FLAG_DOTALL;
+    if (pcre_compile_flags & PCRE_MULTILINE)
+        hs_flags |= HS_FLAG_MULTILINE;
+
+    hs_error_t err;
+    hs_compile_error_t *compile_error = NULL;
+
+    /* First, we attempt to compile the pattern with full Hyperscan support. */
+    err = hs_compile(re, hs_flags, HS_MODE_BLOCK, NULL, &pcre_data->hs_db,
+                     &compile_error);
+    if (err != HS_SUCCESS) {
+        pcre_data->hs_db = NULL; // safety
+        if (compile_error) {
+            hs_free_compile_error(compile_error);
+        }
+    }
+
+    /* If the first attempt failed, we use Hyperscan's prefiltering support to
+     * attempt to build a simplified version of the pattern. */
+    if (!pcre_data->hs_db) {
+        hs_flags |= HS_FLAG_PREFILTER;
+        err = hs_compile(re, hs_flags, HS_MODE_BLOCK, NULL, &pcre_data->hs_db,
+                         &compile_error);
+        if (err != HS_SUCCESS) {
+            pcre_data->hs_db = NULL; // safety
+            if (compile_error) {
+                hs_free_compile_error(compile_error);
+            }
+        }
+    }
+
+    if (!pcre_data->hs_db) {
+        LogMessage("Hyperscan could not prefilter PCRE: %s\n", pcre_data->expression);
+        return;
+    }
+
+    pcre_data->hs_flags = hs_flags;
+
+    // Ensure that the scratch region can handle this database.
+    err = hs_alloc_scratch(pcre_data->hs_db, &pcreScratch);
+    if (err != HS_SUCCESS) {
+        FatalError("hs_alloc_scratch() failed: returned error %d\n", err);
+    }
+
+    if (!(hs_flags & HS_FLAG_PREFILTER) && hyperscan_fixed_width(re, hs_flags)) {
+        pcre_data->hs_noconfirm = 1;
+    }
+}
+
+#endif // INTEL_HYPERSCAN
+
 void SnortPcreParse(struct _SnortConfig *sc, char *data, PcreData *pcre_data, OptTreeNode *otn)
 {
     const char *error;
@@ -498,6 +687,10 @@ void SnortPcreParse(struct _SnortConfig *sc, char *data, PcreData *pcre_data, Op
 
     PcreCheckAnchored(pcre_data);
 
+#ifdef INTEL_HYPERSCAN
+    HyperscanBuild(pcre_data, re, compile_flags);
+#endif
+
     free(free_me);
 
     return;
@@ -560,6 +753,68 @@ void PcreCheckAnchored(PcreData *pcre_data)
     }
 }
 
+#ifdef INTEL_HYPERSCAN
+
+struct hs_context {
+    int matched;
+    int *found_offset;
+};
+
+static int hyperscan_callback(unsigned int id, unsigned long long from,
+                              unsigned long long to, unsigned int flags,
+                              void *ctx) {
+    struct hs_context *hsctx = ctx;
+
+    hsctx->matched = 1;
+    *(hsctx->found_offset) = (int)to; // safe, as buffer has int len
+
+    return 1; // halt matching
+}
+
+// Return 1 when we find the pattern, 0 when we don't.
+static int hyperscan_search(const PcreData *pcre_data, const char *buf, int len,
+                            int start_offset, int *found_offset) {
+    struct hs_context hsctx;
+    hsctx.matched = 0;
+    hsctx.found_offset = found_offset;
+
+    // XXX: we currently ignore start_offset, which might be used to reduce the
+    // size of the buffer being scanned. Need to be careful with anchors,
+    // assertions etc.
+
+    hs_error_t err = hs_scan(pcre_data->hs_db, buf, len, 0, pcreScratch,
+                             hyperscan_callback, &hsctx);
+    if (err != HS_SUCCESS && err != HS_SCAN_TERMINATED) {
+        // An error occurred, fall through to pcre
+        LogMessage("hs_scan returned error %d\n", err);
+        return 0;
+    }
+
+    if (hsctx.matched == 0) {
+        // No matches, no need to run pcre.
+
+#if INTEL_HYPERSCAN_CORRECTNESS_TEST
+        // For correctness testing, run PCRE as well and ensure that it
+        // produces the same result.
+        int result =
+            pcre_exec(pcre_data->re, pcre_data->pe, buf, len, start_offset, 0,
+                      snort_conf->pcre_ovector, snort_conf->pcre_ovector_size);
+        if (result >= 0) {
+            LogMessage("err=%d, result=%d\n", err, result);
+            FatalError("Hyperscan said pattern wouldn't match, pcre says "
+                       "otherwise. Pattern is %s and options are %x\n",
+                       pcre_data->expression, pcre_data->options);
+        }
+#endif
+
+        return 0;
+    }
+
+    return 1;
+}
+
+#endif // INTEL_HYPERSCAN
+
 /**
  * Perform a search of the PCRE data.
  *
@@ -567,6 +822,7 @@ void PcreCheckAnchored(PcreData *pcre_data)
  * @param buf buffer to search
  * @param len size of buffer
  * @param start_offset initial offset into the buffer
+ * @param no_offset_required if a match is found, the caller doesn't need its offset
  * @param found_offset pointer to an integer so that we know where the search ended
  *
  * *found_offset will be set to -1 when the find is unsucessful OR the routine is inverted
@@ -577,6 +833,7 @@ static int pcre_search(const PcreData *pcre_data,
                        const char *buf,
                        int len,
                        int start_offset,
+                       int no_offset_required,
                        int *found_offset)
 {
     int matched;
@@ -596,6 +853,49 @@ static int pcre_search(const PcreData *pcre_data,
 
     *found_offset = -1;
 
+#ifdef INTEL_HYPERSCAN
+    // Prefilter with Hyperscan if available; if Hyperscan says the buffer
+    // cannot match this PCRE, we can fall out here.
+    if (pcre_data->hs_db) {
+        int hs_match = hyperscan_search(pcre_data, buf, len, start_offset, found_offset);
+        int is_prefiltering = pcre_data->hs_flags & HS_FLAG_PREFILTER;
+
+        // If the pattern is inverted and we're not prefiltering AND
+        // start_offset was zero, we don't have to do confirm in PCRE.
+        if (pcre_data->options & SNORT_PCRE_INVERT) {
+            if (start_offset == 0 && !is_prefiltering) {
+                return !hs_match;
+            } else if (!hs_match) {
+                // Hyperscan didn't match, so pcre_exec will not match, so
+                // return that the INVERTED pcre did match.
+                return 1;
+            } else {
+                // Hyperscan did match, we need to confirm with pcre as we're
+                // prefiltering.
+                goto pcre_confirm;
+            }
+        }
+
+        // Note: we must do confirm in PCRE if a start_offset was specified.
+        if (start_offset == 0) {
+            if (pcre_data->hs_noconfirm || (!is_prefiltering && no_offset_required)) {
+                return hs_match; // No confirm necessary.
+            }
+        }
+
+        if (!hs_match) {
+            // No match in Hyperscan, so no PCRE match can occur.
+            return 0;
+        }
+
+        // Otherwise, Hyperscan claims there might be a match. Fall through to
+        // post-confirm with PCRE.
+    }
+
+pcre_confirm:
+
+#endif // INTEL_HYPERSCAN
+
     result = pcre_exec(pcre_data->re,  /* result of pcre_compile() */
                        pcre_data->pe,  /* result of pcre_study()   */
                        buf,            /* the subject string */
@@ -674,7 +974,7 @@ int SnortPcre(void *option_data, Packet *p)
         if ( hb )
         {
             matched = pcre_search(
-                pcre_data, (const char*)hb->buf, hb->length, 0, &found_offset);
+                pcre_data, (const char*)hb->buf, hb->length, 0, 1, &found_offset);
 
             if ( matched )
             {
@@ -756,7 +1056,7 @@ int SnortPcre(void *option_data, Packet *p)
                free(hexbuf);
                );
 
-    matched = pcre_search(pcre_data, (const char *)base_ptr, length, pcre_data->search_offset, &found_offset);
+    matched = pcre_search(pcre_data, (const char *)base_ptr, length, pcre_data->search_offset, 0, &found_offset);
 
     /* set the doe_ptr if we have a valid offset */
     if(found_offset > 0)
diff --git a/snort/src/detection-plugins/sp_pcre.h b/snort/src/detection-plugins/sp_pcre.h
index 0f945ac..8f303e4 100644
--- a/snort/src/detection-plugins/sp_pcre.h
+++ b/snort/src/detection-plugins/sp_pcre.h
@@ -49,6 +49,10 @@
 
 void SetupPcre(void);
 
+#ifdef INTEL_HYPERSCAN
+struct hs_database;
+#endif
+
 #include <pcre.h>
 typedef struct _PcreData
 {
@@ -57,6 +61,11 @@ typedef struct _PcreData
     int options;        /* sp_pcre specfic options (relative & inverse) */
     char *expression;
     uint32_t search_offset;
+#ifdef INTEL_HYPERSCAN
+    struct hs_database *hs_db; /* hyperscan database, if used */
+    int hs_flags;              /* hyperscan flags used for compile */
+    int hs_noconfirm;          /* hyperscan matches don't need confirm */
+#endif // INTEL_HYPERSCAN
 } PcreData;
 
 void PcreCapture(struct _SnortConfig *sc, const void *code, const void *extra);
diff --git a/snort/src/fpcreate.c b/snort/src/fpcreate.c
index 1c4646e..9cf606d 100644
--- a/snort/src/fpcreate.c
+++ b/snort/src/fpcreate.c
@@ -1008,6 +1008,13 @@ int fpSetDetectSearchMethod(FastPatternConfig *fp, char *method)
        LogMessage("   Search-Method = Intel CPM\n");
     }
 #endif
+#ifdef INTEL_HYPERSCAN
+    else if( !strcasecmp(method,"hyperscan") )
+    {
+       fp->search_method = MPSE_HYPERSCAN;
+       LogMessage("   Search-Method = Hyperscan\n");
+    }
+#endif
     else
     {
        return -1;
@@ -1533,12 +1540,24 @@ static int fpFinishPortGroupRule(SnortConfig *sc, PORT_GROUP *pg, PmType pm_type
         if (fpDetectGetDebugPrintFastPatterns(fp))
             PrintFastPatternInfo(otn, pmd, pattern, pattern_length, pm_type);
 
+#ifdef INTEL_HYPERSCAN
+        // If a pattern is marked with "fast_pattern: only;" it is assumed
+        // to be caseless (since all the AC matchers etc. run caselessly). We
+        // enforce this here so that the Intel PM integration can take
+        // advantage of its ability to run casefully as well. See the ternary
+        // nocase branch below.
+#endif
+
         mpseAddPatternWithSnortConfig(
                 sc,
                 pg->pgPms[pm_type],
                 pattern,
                 pattern_length,
+#ifdef INTEL_HYPERSCAN
+                pmd->fp_only ? 1 : pmd->nocase, // Force nocase if fp_only
+#else
                 pmd->nocase,
+#endif // INTEL_HYPERSCAN
                 pmd->offset,
                 pmd->depth,
                 (unsigned)pmd->exception_flag,
diff --git a/snort/src/sfutil/Makefile.am b/snort/src/sfutil/Makefile.am
index f122dec..699cc6a 100644
--- a/snort/src/sfutil/Makefile.am
+++ b/snort/src/sfutil/Makefile.am
@@ -6,6 +6,10 @@ if HAVE_INTEL_SOFT_CPM
 INTEL_SOFT_CPM_SOURCES = intel-soft-cpm.c intel-soft-cpm.h
 endif
 
+if HAVE_INTEL_HYPERSCAN
+INTEL_HYPERSCAN_SOURCES = hyperscan.c hyperscan.h
+endif
+
 if BUILD_OPENSSL_MD5
 OPENSSL_MD5 = \
     md5.c md5.h 
@@ -65,6 +69,7 @@ libsfutil_a_SOURCES = \
 	mpse_methods.h \
 	sfdebug.h \
     $(INTEL_SOFT_CPM_SOURCES) \
+    $(INTEL_HYPERSCAN_SOURCES) \
     $(OPENSSL_MD5) \
     $(OPENSSL_SHA)
 
diff --git a/snort/src/sfutil/hyperscan.c b/snort/src/sfutil/hyperscan.c
new file mode 100644
index 0000000..2241535
--- /dev/null
+++ b/snort/src/sfutil/hyperscan.c
@@ -0,0 +1,359 @@
+/*
+** Copyright (c) 2015-2016, Intel Corporation.
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License Version 2 as
+** published by the Free Software Foundation.  You may not use, modify or
+** distribute this program under any other version of the GNU General
+** Public License.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+**
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "hyperscan.h"
+#include "snort.h"
+#include "snort_debug.h"
+#include "util.h"
+
+#define INITIAL_PATTERN_ARRAY_ALLOC_SIZE 10
+
+// Summary information; this is global and static for now.
+typedef struct _HyperscanSummary {
+    unsigned int db_count; // number of databases
+    size_t db_bytes;       // total bytes compiled
+    size_t scratch_size;   // size of scratch space
+} HyperscanSummary;
+
+static HyperscanSummary summary;
+
+HyperscanPm *HyperscanNew(void (*user_free)(void *p),
+                          void (*option_tree_free)(void **p),
+                          void (*neg_list_free)(void **p)) {
+    HyperscanPm *pm = SnortAlloc(sizeof(HyperscanPm));
+    pm->user_free = user_free;
+    pm->option_tree_free = option_tree_free;
+    pm->neg_list_free = neg_list_free;
+
+    pm->patterns_capacity = INITIAL_PATTERN_ARRAY_ALLOC_SIZE;
+    pm->patterns = SnortAlloc(sizeof(HyperscanPattern) * pm->patterns_capacity);
+
+    return pm;
+}
+
+void HyperscanFree(HyperscanPm *pm) {
+    if (!pm) {
+        return;
+    }
+
+    unsigned int i = 0;
+    for (; i < pm->patterns_len; i++) {
+        HyperscanPattern *hp = &pm->patterns[i];
+        free(hp->pattern);
+        if (pm->user_free && hp->user_data) {
+            pm->user_free(hp->user_data);
+        }
+        if (pm->neg_list_free && hp->neg_list) {
+            pm->neg_list_free(&hp->neg_list);
+        }
+        if (pm->option_tree_free && hp->rule_option_tree) {
+            pm->option_tree_free(&hp->rule_option_tree);
+        }
+    }
+
+    hs_free_database(pm->db);
+    free(pm->patterns);
+    free(pm);
+}
+
+HyperscanContext *HyperscanNewContext() {
+    HyperscanContext *ctx = SnortAlloc(sizeof(HyperscanContext));
+    ctx->scratch = NULL;
+    return ctx;
+}
+
+void HyperscanFreeContext(HyperscanContext *ctx) {
+    if (!ctx) {
+        return;
+    }
+    hs_free_scratch(ctx->scratch);
+    free(ctx);
+}
+
+// Render the given literal as a hex-escaped pattern.
+static
+char *makeHex(const unsigned char *pat, unsigned patlen) {
+    size_t hexlen = patlen * 4;
+    char *hexbuf = SnortAlloc(hexlen + 1);
+    unsigned i;
+    char *buf;
+    for (i = 0, buf = hexbuf; i < patlen; i++, buf += 4) {
+        snprintf(buf, 5, "\\x%02x", (unsigned char)pat[i]);
+    }
+    hexbuf[hexlen] = '\0';
+    return hexbuf;
+}
+
+int HyperscanAddPattern(struct _SnortConfig *sc, HyperscanPm *pm,
+                        unsigned char *pat, int patlen, int nocase, int offset,
+                        int depth, int negative, void *id, int iid) {
+    if (!pm) {
+        return -1;
+    }
+
+    // Reallocate patterns array if it's at capacity.
+    if (pm->patterns_len + 1 > pm->patterns_capacity) {
+        unsigned growth = pm->patterns_capacity / 2 > 0 ? pm->patterns_capacity / 2 : 1;
+        pm->patterns_capacity += growth;
+        HyperscanPattern *tmp = SnortAlloc(sizeof(HyperscanPattern) * pm->patterns_capacity);
+        memcpy(tmp, pm->patterns, sizeof(HyperscanPattern) * pm->patterns_len);
+        free(pm->patterns);
+        pm->patterns = tmp;
+    }
+
+    HyperscanPattern *hp = &pm->patterns[pm->patterns_len];
+    hp->user_data = id;
+    hp->pattern = makeHex(pat, patlen);
+    hp->pattern_len = patlen;
+    hp->nocase = nocase;
+    hp->offset = offset;
+    hp->depth = depth;
+    hp->negative = negative;
+    hp->id = iid;
+    hp->pattern_id = pm->patterns_len++;
+
+    return 0;
+}
+
+int HyperscanCompileWithSnortConf(struct _SnortConfig *sc, HyperscanPm *pm,
+                                  int (*build_tree)(struct _SnortConfig *,
+                                                    void *id,
+                                                    void **existing_tree),
+                                  int (*neg_list_func)(void *id, void **list)) {
+    if (!pm) {
+        return -1;
+    }
+
+    // The Hyperscan compiler takes its patterns in a group of arrays.
+    const unsigned num_patterns = pm->patterns_len;
+    const char **patterns = SnortAlloc(num_patterns * sizeof(char *));
+    unsigned int *flags = SnortAlloc(num_patterns * sizeof(unsigned int));
+    unsigned int *ids = SnortAlloc(num_patterns * sizeof(unsigned int));
+    hs_expr_ext_t *exts = SnortAlloc(num_patterns * sizeof(hs_expr_ext_t));
+    const hs_expr_ext_t **ext =
+        SnortAlloc(num_patterns * sizeof(hs_expr_ext_t *));
+
+    unsigned int i = 0;
+    for (; i < num_patterns; i++) {
+        const HyperscanPattern *hp = &pm->patterns[i];
+        patterns[i] = hp->pattern;
+        flags[i] = HS_FLAG_SINGLEMATCH;
+        if (hp->nocase) {
+            flags[i] |= HS_FLAG_CASELESS;
+        }
+        ids[i] = i;
+        exts[i].flags = 0;
+        if (hp->offset != 0) {
+            exts[i].flags |= HS_EXT_FLAG_MIN_OFFSET;
+            exts[i].min_offset = hp->offset + hp->pattern_len;
+        }
+        if (hp->depth != 0) {
+            exts[i].flags |= HS_EXT_FLAG_MAX_OFFSET;
+            exts[i].max_offset = hp->offset + hp->depth;
+        }
+
+        ext[i] = &exts[i];
+    }
+
+    hs_compile_error_t *compile_error = NULL;
+    hs_error_t error = hs_compile_ext_multi(patterns, flags, ids, ext,
+                num_patterns, HS_MODE_BLOCK, NULL, &(pm->db), &compile_error);
+
+    free(patterns);
+    free(flags);
+    free(ids);
+    free(exts);
+    free(ext);
+
+    if (compile_error != NULL) {
+        FatalError("hs_compile_multi() failed: %s (expression: %d)\n",
+                   compile_error->message, compile_error->expression);
+        hs_free_compile_error(compile_error);
+        return -1;
+    }
+
+    if (error != HS_SUCCESS) {
+        FatalError("hs_compile_multi() failed: error %d\n", error);
+        return -1;
+    }
+
+    // Share the global Hyperscan context, and ensure that it has enough
+    // scratch for this database.
+    if (!sc->hyperscan_ctx) {
+        FatalError("No Hyperscan context structure!\n");
+        return -1;
+    }
+    pm->ctx = sc->hyperscan_ctx;
+    error = hs_alloc_scratch(pm->db, &pm->ctx->scratch);
+
+    if (error != HS_SUCCESS) {
+        FatalError("hs_alloc_scratch() failed: error %d\n", error);
+        return -1;
+    }
+
+    size_t scratch_size = 0;
+    error = hs_scratch_size(pm->ctx->scratch, &scratch_size);
+    if (error != HS_SUCCESS) {
+        FatalError("hs_scratch_size() failed: error %d\n", error);
+        return -1;
+    }
+
+    size_t db_size = 0;
+    error = hs_database_size(pm->db, &db_size);
+    if (error != HS_SUCCESS) {
+        FatalError("hs_database_size() failed: error %d\n", error);
+        return -1;
+    }
+
+    DEBUG_WRAP(DebugMessage(DEBUG_PATTERN_MATCH,
+                            "Built Hyperscan database: %u patterns, %zu bytes\n",
+                            num_patterns, db_size));
+
+    // Construct Snort's neg lists and option trees.
+    for (i = 0; i < num_patterns; i++) {
+        HyperscanPattern *hp = &pm->patterns[i];
+        if (hp->negative) {
+            neg_list_func(hp->user_data, &hp->neg_list);
+        } else {
+            build_tree(sc, hp->user_data, &hp->rule_option_tree);
+        }
+
+        build_tree(sc, NULL, &hp->rule_option_tree);
+    }
+
+    // Update summary info.
+    summary.db_count++;
+    summary.db_bytes += db_size;
+    summary.scratch_size = scratch_size;
+
+    return 0;
+}
+
+// Match callback, called by hs_scan for every match.
+static
+int onMatch(unsigned int id, unsigned long long from, unsigned long long to,
+            unsigned int flags, void *ctx) {
+    const HyperscanPm *pm = ctx;
+    const HyperscanPattern *hp = &pm->patterns[id];
+
+    if (pm->match(hp->user_data, hp->rule_option_tree, 0, pm->data,
+                  hp->neg_list) > 0) {
+        return 1; // Halt matching.
+    }
+
+    return 0; // Continue matching.
+}
+
+int HyperscanSearch(HyperscanPm *pm, unsigned char *t, int tlen,
+                    int (*match)(void *id, void *tree, int index, void *data,
+                                 void *neg_list),
+                    void *data) {
+    pm->data = data;
+    pm->match = match;
+
+    hs_error_t error = hs_scan(pm->db, (const char *)t, tlen, 0,
+                               pm->ctx->scratch, onMatch, pm);
+
+    if (error != HS_SUCCESS) {
+        FatalError("hs_scan() failed: error %d\n", error);
+    }
+
+    return 0;
+}
+
+int HyperscanGetPatternCount(HyperscanPm *pm) {
+    if (!pm) {
+        return 0;
+    }
+    return pm->patterns_len;
+}
+
+void HyperscanPrintInfo(HyperscanPm *pm) {
+    size_t db_size = 0;
+    hs_database_size(pm->db, &db_size);
+
+    char *info = NULL;
+    hs_database_info(pm->db, &info);
+
+    unsigned int min_len = ~0U;
+    unsigned int max_len = 0;
+    unsigned int total_len = 0;
+    unsigned int nocase_count = 0;
+    unsigned int offset_count = 0;
+    unsigned int depth_count = 0;
+    unsigned int negative_count = 0;
+
+    unsigned int i;
+    for (i = 0; i < pm->patterns_len; i++) {
+        const HyperscanPattern *hp = &pm->patterns[i];
+        total_len += hp->pattern_len;
+        if (hp->pattern_len < min_len) {
+            min_len = hp->pattern_len;
+        }
+        if (hp->pattern_len > max_len) {
+            max_len = hp->pattern_len;
+        }
+        if (hp->nocase) {
+            nocase_count++;
+        }
+        if (hp->offset) {
+            offset_count++;
+        }
+        if (hp->depth) {
+            depth_count++;
+        }
+        if (hp->negative) {
+            negative_count++;
+        }
+    }
+
+    LogMessage("+--[Pattern Matcher:Hyperscan]--------------------------------\n");
+    LogMessage("| Number of patterns : %u\n", pm->patterns_len);
+    LogMessage("|    with nocase     : %u\n", nocase_count);
+    LogMessage("|    with offset     : %u\n", offset_count);
+    LogMessage("|    with depth      : %u\n", depth_count);
+    LogMessage("|    with negative   : %u\n", negative_count);
+    LogMessage("| Min pattern length : %u\n", min_len);
+    LogMessage("| Max pattern length : %u\n", max_len);
+    LogMessage("| Avg pattern length : %.2f\n", (float)total_len / pm->patterns_len);
+    LogMessage("|\n");
+    LogMessage("| Database size (KB) : %.2f\n", (float)db_size / 1024);
+    LogMessage("| Database info      : %s\n", info);
+    LogMessage("+-------------------------------------------------------------\n");
+
+    free(info);
+}
+
+void HyperscanPrintSummary() {
+    LogMessage("+--[ Intel Hyperscan Summary ]--------------------------------\n");
+    LogMessage("| Hyperscan version   : %s\n", hs_version());
+    LogMessage("| Number of databases : %u\n", summary.db_count);
+    LogMessage("| Memory (MB)         : %.2f\n", (float)summary.db_bytes / (1024 * 1024));
+    LogMessage("| Scratch (KB)        : %.2f\n", (float)summary.scratch_size / 1024);
+    LogMessage("+-------------------------------------------------------------\n");
+}
diff --git a/snort/src/sfutil/hyperscan.h b/snort/src/sfutil/hyperscan.h
new file mode 100644
index 0000000..490273e
--- /dev/null
+++ b/snort/src/sfutil/hyperscan.h
@@ -0,0 +1,101 @@
+/*
+** Copyright (c) 2015-2016, Intel Corporation.
+**
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License Version 2 as
+** published by the Free Software Foundation.  You may not use, modify or
+** distribute this program under any other version of the GNU General
+** Public License.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+**
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software
+** Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <hs.h>
+
+#ifndef SNORT_HYPERSCAN_H
+#define SNORT_HYPERSCAN_H
+
+struct _SnortConfig;
+
+typedef struct _HyperscanPattern {
+    char *pattern;
+    unsigned int pattern_len;
+    unsigned int nocase;
+    unsigned int offset;
+    unsigned int depth;
+    unsigned int negative;
+    int id;                 /* pattern id passed in from mpse */
+    unsigned int pattern_id; /* actual pattern id */
+
+    void *user_data;
+    void *rule_option_tree;
+    void *neg_list;
+} HyperscanPattern;
+
+// Context shared between all Hyperscan matchers.
+typedef struct _HyperscanContext {
+    hs_scratch_t *scratch;
+} HyperscanContext;
+
+typedef struct _HyperscanPm {
+    hs_database_t *db;
+    HyperscanContext *ctx;
+    HyperscanPattern *patterns;
+    unsigned int patterns_len; // number of elements
+    unsigned int patterns_capacity; // allocated capacity
+
+    /* Temporary data for match callback */
+    void *data;
+    int (*match)(void *id, void *tree, int index, void *data, void *neg_list);
+
+    void (*user_free)(void *);
+    void (*option_tree_free)(void **);
+    void (*neg_list_free)(void **);
+} HyperscanPm;
+
+/*
+ * Prototypes
+ */
+
+HyperscanPm *HyperscanNew(void (*userfree)(void *p),
+                          void (*optiontreefree)(void **p),
+                          void (*neg_list_free)(void **p));
+void HyperscanFree(HyperscanPm *pm);
+
+HyperscanContext *HyperscanNewContext();
+void HyperscanFreeContext(HyperscanContext *ctx);
+
+int HyperscanAddPattern(struct _SnortConfig *sc, HyperscanPm *pm,
+                        unsigned char *pat, int patlen, int nocase, int offset,
+                        int depth, int negative, void *id, int iid);
+
+int HyperscanCompileWithSnortConf(struct _SnortConfig *sc, HyperscanPm *pp,
+                                  int (*build_tree)(struct _SnortConfig *,
+                                                    void *id,
+                                                    void **existing_tree),
+                                  int (*neg_list_func)(void *id, void **list));
+
+int HyperscanSearch(HyperscanPm *pm, unsigned char *t, int tlen,
+                    int (*match)(void *id, void *tree, int index, void *data,
+                                 void *neg_list),
+                    void *data);
+
+int HyperscanGetPatternCount(HyperscanPm *pm);
+
+void HyperscanPrintInfo(HyperscanPm *pm);
+
+void HyperscanPrintSummary();
+
+#endif // SNORT_HYPERSCAN_H
diff --git a/snort/src/sfutil/mpse.c b/snort/src/sfutil/mpse.c
index 3acbfc5..d0c1af9 100644
--- a/snort/src/sfutil/mpse.c
+++ b/snort/src/sfutil/mpse.c
@@ -51,6 +51,10 @@
 #include "intel-soft-cpm.h"
 #endif
 
+#ifdef INTEL_HYPERSCAN
+#include "hyperscan.h"
+#endif
+
 #include "profiler.h"
 #include "snort.h"
 #ifdef PERF_PROFILING
@@ -204,6 +208,11 @@ void * mpseNewWithSnortConfig( struct _SnortConfig *sc,
             p->obj=IntelPmNew(sc, userfree, optiontreefree, neg_list_free);
             break;
 #endif
+#ifdef INTEL_HYPERSCAN
+        case MPSE_HYPERSCAN:
+            p->obj = HyperscanNew(userfree, optiontreefree, neg_list_free);
+            break;
+#endif
         default:
             /* p is free'd below if no case */
             break;
@@ -294,6 +303,13 @@ void   mpseFree( void * pvoid )
             free(p);
             break;
 #endif
+#ifdef INTEL_HYPERSCAN
+        case MPSE_HYPERSCAN:
+            if (p->obj)
+                HyperscanFree((HyperscanPm *)p->obj);
+            free(p);
+            return;
+#endif
 
         default:
             return;
@@ -369,6 +385,11 @@ int  mpseAddPatternWithSnortConfig ( SnortConfig *sc, void * pvoid, void * P, in
        return IntelPmAddPattern(sc, (IntelPm *)p->obj, (unsigned char *)P, m,
                noCase, negative, ID, IID);
 #endif
+#ifdef INTEL_HYPERSCAN
+     case MPSE_HYPERSCAN:
+       return HyperscanAddPattern(sc, (HyperscanPm *)p->obj, (unsigned char *)P, m,
+               noCase, offset, depth, negative, ID, IID);
+#endif
      default:
        return -1;
    }
@@ -459,6 +480,10 @@ int  mpsePrepPatternsWithSnortConf  ( struct _SnortConfig *sc, void * pvoid,
      case MPSE_INTEL_CPM:
        return IntelPmFinishGroup(sc, (IntelPm *)p->obj, build_tree, neg_list_func);
 #endif
+#ifdef INTEL_HYPERSCAN
+     case MPSE_HYPERSCAN:
+       return HyperscanCompileWithSnortConf(sc, (HyperscanPm *)p->obj, build_tree, neg_list_func);
+#endif
 
      default:
        retv = 1;
@@ -501,6 +526,11 @@ int mpsePrintInfo( void *pvoid )
      case MPSE_ACB:
      case MPSE_ACSB:
       return acsmPrintDetailInfo2( (ACSM_STRUCT2*) p->obj );
+#ifdef INTEL_HYPERSCAN
+     case MPSE_HYPERSCAN:
+      HyperscanPrintInfo( (HyperscanPm*) p->obj );
+      break;
+#endif
 
      default:
        return 1;
@@ -541,6 +571,11 @@ int mpsePrintSummary(int method)
 
             }
             break;
+#ifdef INTEL_HYPERSCAN
+        case MPSE_HYPERSCAN:
+            HyperscanPrintSummary();
+            break;
+#endif
         default:
             break;
     }
@@ -579,6 +614,11 @@ int mpsePrintSummaryWithSnortConfig(SnortConfig *sc, int method)
 
             }
             break;
+#ifdef INTEL_HYPERSCAN
+        case MPSE_HYPERSCAN:
+            HyperscanPrintSummary();
+            break;
+#endif
         default:
             break;
     }
@@ -651,6 +691,13 @@ int mpseSearch( void *pvoid, const unsigned char * T, int n,
         PREPROC_PROFILE_END(mpsePerfStats);
         return ret;
 #endif
+#ifdef INTEL_HYPERSCAN
+     case MPSE_HYPERSCAN:
+        ret = HyperscanSearch((HyperscanPm *)p->obj, (unsigned char *)T, n, action, data);
+        *current_state = 0;
+        PREPROC_PROFILE_END(mpsePerfStats);
+        return ret;
+#endif
 
      default:
        PREPROC_PROFILE_END(mpsePerfStats);
@@ -694,6 +741,9 @@ int mpseSearchAll( void *pvoid, const unsigned char * T, int n,
 #ifdef INTEL_SOFT_CPM
      case MPSE_INTEL_CPM:
 #endif
+#ifdef INTEL_HYPERSCAN
+     case MPSE_HYPERSCAN:
+#endif
      default:
       //search all not implemented.
        PREPROC_PROFILE_END(mpsePerfStats);
@@ -729,6 +779,10 @@ int mpseGetPatternCount(void *pvoid)
         case MPSE_INTEL_CPM:
             return IntelGetPatternCount((IntelPm *)p->obj);
 #endif
+#ifdef INTEL_HYPERSCAN
+        case MPSE_HYPERSCAN:
+            return HyperscanGetPatternCount((HyperscanPm *)p->obj);
+#endif
     }
     return 0;
 }
diff --git a/snort/src/sfutil/mpse_methods.h b/snort/src/sfutil/mpse_methods.h
index 2d73318..a123fbb 100644
--- a/snort/src/sfutil/mpse_methods.h
+++ b/snort/src/sfutil/mpse_methods.h
@@ -44,6 +44,10 @@
 #define MPSE_INTEL_CPM 14
 #endif /* INTEL_SOFT_CPM */
 
+#ifdef INTEL_HYPERSCAN
+#define MPSE_HYPERSCAN 20
+#endif /* INTEL_HYPERSCAN */
+
 typedef enum {
     MPSE_PATTERN_CASE,
     MPSE_PATTERN_NOCASE
diff --git a/snort/src/snort.c b/snort/src/snort.c
index 0585144..defe09b 100644
--- a/snort/src/snort.c
+++ b/snort/src/snort.c
@@ -158,6 +158,10 @@
 #include "sfutil/intel-soft-cpm.h"
 #endif
 
+#ifdef INTEL_HYPERSCAN
+#include "sfutil/hyperscan.h"
+#endif
+
 #include "session_api.h"
 
 #include "stream_common.h"
@@ -4189,6 +4193,10 @@ SnortConfig * SnortConfNew(void)
 
     sc->paf_max = DEFAULT_PAF_MAX;
 
+#ifdef INTEL_HYPERSCAN
+    sc->hyperscan_ctx = HyperscanNewContext();
+#endif
+
     /* Default secure hash pattern type */
     sc->Default_Protected_Content_Hash_Type = SECHASH_NONE;
 
@@ -4374,6 +4382,10 @@ void SnortConfFree(SnortConfig *sc)
     IntelPmRelease(sc->ipm_handles);
 #endif
 
+#ifdef INTEL_HYPERSCAN
+    HyperscanFreeContext(sc->hyperscan_ctx);
+#endif
+
 #ifdef SNORT_RELOAD
     FreePreprocessorReloadData(sc);
 #endif
diff --git a/snort/src/snort.h b/snort/src/snort.h
index 22b6a64..4931c01 100644
--- a/snort/src/snort.h
+++ b/snort/src/snort.h
@@ -680,9 +680,17 @@ struct _MandatoryEarlySessionCreator;
 struct _ReloadAdjustEntry;
 #endif
 struct _fileConfig;
+
+#ifdef INTEL_HYPERSCAN
+struct _HyperscanContext;
+#endif
+
 typedef struct _SnortConfig
 {
     RunMode run_mode;
+#ifdef INTEL_HYPERSCAN
+    struct _HyperscanContext *hyperscan_ctx;
+#endif
     int run_mode_flags;
     int run_flags;
     int output_flags;
@@ -962,6 +970,9 @@ typedef struct _SnortConfig
 #ifdef INTEL_SOFT_CPM
     struct _IntelPmHandles *ipm_handles;
 #endif
+#ifdef INTEL_HYPERSCAN
+    struct _HyperscanContext *hyperscan_ctx;
+#endif
 
 /* Used when a user defines a new rule type (ruletype keyword)
  * It points to the new rule type's ListHead and is used for accessing the
